// Core Grafana history https://github.com/grafana/grafana/blob/v11.0.0-preview/public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/index.ts
import { TimeRange } from '@grafana/data';
import type { Monaco, monacoTypes } from '@grafana/ui';

import { CompletionType, getCompletions } from './completions';
import { DataProvider } from './data_provider';
import { getSituation } from './situation';
import { NeverCaseError } from './util';

export function getSuggestOptions(): monacoTypes.editor.ISuggestOptions {
  return {
    // monaco-editor sometimes provides suggestions automatically, i am not
    // sure based on what, seems to be by analyzing the words already
    // written.
    // to try it out:
    // - enter `go_goroutines{job~`
    // - have the cursor at the end of the string
    // - press ctrl-enter
    // - you will get two suggestions
    // those were not provided by grafana, they are offered automatically.
    // i want to remove those. the only way i found is:
    // - every suggestion-item has a `kind` attribute,
    //   that controls the icon to the left of the suggestion.
    // - items auto-generated by monaco have `kind` set to `text`.
    // - we make sure grafana-provided suggestions do not have `kind` set to `text`.
    // - and then we tell monaco not to show suggestions of kind `text`
    showWords: false,
  };
}

function getMonacoCompletionItemKind(type: CompletionType, monaco: Monaco): monacoTypes.languages.CompletionItemKind {
  switch (type) {
    case 'DURATION':
      return monaco.languages.CompletionItemKind.Unit;
    case 'FUNCTION':
      return monaco.languages.CompletionItemKind.Variable;
    case 'HISTORY':
      return monaco.languages.CompletionItemKind.Snippet;
    case 'LABEL_NAME':
      return monaco.languages.CompletionItemKind.Enum;
    case 'LABEL_VALUE':
      return monaco.languages.CompletionItemKind.EnumMember;
    case 'METRIC_NAME':
      return monaco.languages.CompletionItemKind.Constructor;
    default:
      throw new NeverCaseError(type);
  }
}

// Shared state for completion provider
export interface CompletionProviderState {
  isManualTriggerRequested: boolean;
  lastTriggeredWordLength: number;
  lastTriggeredWord: string;
}

// Create shared state for completion provider
export function createCompletionProviderState(): CompletionProviderState {
  return {
    isManualTriggerRequested: false,
    lastTriggeredWordLength: 0,
    lastTriggeredWord: '',
  };
}

export function getCompletionProvider(
  monaco: Monaco,
  dataProvider: DataProvider,
  timeRange: TimeRange,
  sharedState?: CompletionProviderState
): monacoTypes.languages.CompletionItemProvider {
  // Debounce mechanism to delay completions after user stops typing
  let debounceTimer: ReturnType<typeof setTimeout> | null = null;
  const DEBOUNCE_DELAY = 300; // 300ms delay after typing stops

  // Use shared state or create local state
  const state = sharedState || {
    isManualTriggerRequested: false,
    lastTriggeredWordLength: 0,
    lastTriggeredWord: '',
  };

  // Track completion trigger points for 3-character increments
  // Use state directly instead of local variables to ensure synchronization
  const getLastTriggeredWordLength = () => state.lastTriggeredWordLength;
  const setLastTriggeredWordLength = (value: number) => {
    state.lastTriggeredWordLength = value;
  };
  const getLastTriggeredWord = () => state.lastTriggeredWord;
  const setLastTriggeredWord = (value: string) => {
    state.lastTriggeredWord = value;
  };

  // Track deletion events to reset completion state
  const setupDeletionTracking = (model: monacoTypes.editor.ITextModel) => {
    // Listen for content changes to detect deletions
    model.onDidChangeContent((e) => {
      // Check if any change was a deletion
      const hasDeletion = e.changes.some((change) => change.text === '' && change.rangeLength > 0);

      if (hasDeletion) {
        console.log('Deletion detected, resetting completion state');
        // Reset completion tracking on deletion
        setLastTriggeredWordLength(0);
        setLastTriggeredWord('');

        // Clear any pending completion timers
        if (debounceTimer) {
          clearTimeout(debounceTimer);
          debounceTimer = null;
        }
      }
    });
  };

  let isTrackingSetup = false;

  const provideCompletionItems = (
    model: monacoTypes.editor.ITextModel,
    position: monacoTypes.Position,
    context: monacoTypes.languages.CompletionContext
  ): monacoTypes.languages.ProviderResult<monacoTypes.languages.CompletionList> => {
    // Set up deletion tracking once per model
    if (!isTrackingSetup) {
      setupDeletionTracking(model);
      isTrackingSetup = true;
    }

    const word = model.getWordAtPosition(position);
    const range =
      word != null
        ? monaco.Range.lift({
            startLineNumber: position.lineNumber,
            endLineNumber: position.lineNumber,
            startColumn: word.startColumn,
            endColumn: word.endColumn,
          })
        : monaco.Range.fromPositions(position);

    // Check if we have at least 3 characters typed for word completion
    // Allow completions for trigger characters (like {, [, etc.) regardless of length
    const triggerChars = ['{', ',', '[', '(', '=', '~', ' ', '"'];
    const isTriggeredByChar = triggerChars.some(
      (char) =>
        model.getValueInRange({
          startLineNumber: position.lineNumber,
          endLineNumber: position.lineNumber,
          startColumn: Math.max(1, position.column - 1),
          endColumn: position.column,
        }) === char
    );

    // Check if this is a manual trigger (Ctrl+Space) using our custom flag
    if (state.isManualTriggerRequested) {
      state.isManualTriggerRequested = false;
      return executeCompletionLogic(model, position, range, dataProvider, timeRange, word?.word);
    }

    // For trigger characters, execute immediately without debouncing
    if (isTriggeredByChar) {
      return executeCompletionLogic(model, position, range, dataProvider, timeRange, word?.word);
    }

    // For word completions, check if we should trigger based on 3-character increments
    if (word && word.word.length >= 3) {
      const currentWord = word.word;
      const currentWordLength = currentWord.length;

      // Reset tracking if word changed (user moved cursor or started typing a different word)
      if (getLastTriggeredWord() && !currentWord.startsWith(getLastTriggeredWord())) {
        setLastTriggeredWordLength(0);
        setLastTriggeredWord('');
      }

      // Check if we should trigger completion based on 3-character increments
      const shouldTrigger =
        (getLastTriggeredWordLength() === 0 && currentWordLength >= 3) || // First 3 characters
        (getLastTriggeredWordLength() > 0 && currentWordLength >= getLastTriggeredWordLength() + 3); // Next 3 characters

      if (shouldTrigger) {
        if (debounceTimer) {
          clearTimeout(debounceTimer);
        }

        return new Promise((resolve) => {
          debounceTimer = setTimeout(() => {
            setLastTriggeredWordLength(currentWordLength);
            setLastTriggeredWord(currentWord);
            executeCompletionLogic(model, position, range, dataProvider, timeRange, word?.word).then(resolve);
          }, DEBOUNCE_DELAY);
        });
      }
    }

    // If we don't meet the criteria, return empty suggestions
    return { suggestions: [], incomplete: false };
  };

  // Extract completion logic into a separate function
  const executeCompletionLogic = async (
    model: monacoTypes.editor.ITextModel,
    position: monacoTypes.Position,
    range: monacoTypes.Range,
    dataProvider: DataProvider,
    timeRange: TimeRange,
    wordText?: string
  ): Promise<monacoTypes.languages.CompletionList> => {
    // documentation says `position` will be "adjusted" in `getOffsetAt`
    // i don't know what that means, to be sure i clone it

    const positionClone = {
      column: position.column,
      lineNumber: position.lineNumber,
    };
    dataProvider.monacoSettings.setInputInRange(model.getValueInRange(range));

    // Check to see if the browser supports window.getSelection()
    if (window.getSelection) {
      const selectedText = window.getSelection()?.toString();
      // If the user has selected text, adjust the cursor position to be at the start of the selection, instead of the end
      if (selectedText && selectedText.length > 0) {
        positionClone.column = positionClone.column - selectedText.length;
      }
    }

    const offset = model.getOffsetAt(positionClone);
    const situation = getSituation(model.getValue(), offset);
    const completionsPromise =
      situation != null ? getCompletions(situation, dataProvider, timeRange, wordText) : Promise.resolve([]);

    const items = await completionsPromise;
    // monaco by-default alphabetically orders the items.
    // to stop it, we use a number-as-string sortkey,
    // so that monaco keeps the order we use
    const maxIndexDigits = items.length.toString().length;
    const suggestions: monacoTypes.languages.CompletionItem[] = items.map((item, index) => ({
      kind: getMonacoCompletionItemKind(item.type, monaco),
      label: item.label,
      insertText: item.insertText,
      insertTextRules: item.insertTextRules,
      detail: item.detail,
      documentation: item.documentation,
      sortText: index.toString().padStart(maxIndexDigits, '0'), // to force the order we have
      range,
      command: item.triggerOnInsert
        ? {
            id: 'editor.action.triggerSuggest',
            title: '',
          }
        : undefined,
    }));
    return { suggestions, incomplete: dataProvider.monacoSettings.suggestionsIncomplete };
  };

  return {
    triggerCharacters: ['{', ',', '[', '(', '=', '~', ' ', '"'],
    provideCompletionItems,
  };
}
